# C++ MML Player with YM2612 Emulator
### By CaptainYS http://www.ysflight.com


## Introduction

This C++ library generates a fragment of raw wave data that can be played with a conventional audio-playing library from MML (Music Macro Language).  The tones are generated by using my YM2612 emulator library called Tsugaru-Ben, which stands for Tsugaru dialect in Japanese.

It used to be so easy to play a music by programming with MML (Music Macro Language).  I was able to play simple tones by writing:

***
```
PLAY "CDEFGAB"
```
***

I spent so much time typing in (or translating) music score in MML program and played on my FM77AV and FM TOWNS.

The time has passed and MML was gone from programming.  Majority of high-level libraries that are supplied by the operating-system vendors support playing a music file like MP3, which come with two major problems:

1. Platform dependency.
2. What if you cannot play an instrument?  What to do with copyright?  There are many musics that are not copyrighted or copyright expired like classical musics.  However, as soon as someone plays it, some rights are attached to the performer.  Unless you are proficient in a musical instrument, you cannot create a MP3 file that is copyrighted to you.

You can easily import a MP3-player library, which solves the platform-dependency problem, in return, your project gets an additional dependency.  Well, if the library is open source, you may be able to add the source code in your build tree, but what if the library is discontinued and the operating system deprecated and completely removed the player library used by the MP3-player library?  And, it still does not solve the copyright problem.

Tell you what.  The biggest problem?  No fun!  I was able to enjoy playing computer music with MML when I was learning BASIC.  It's so much fun!  It's an excellent introduction for programming!  This fun aspect has been missing from C++!

The library needs to be small.  It needs to be portable.  It needs to be easily ported to a new audio-playing API.  It should give you a power to play a music even if you are not proficient in a musical instrument.  It needs to be fun!

So, here it is.  I release it with MIT license.  No other dependency.  You need to write a piece of code that gives the raw wave file to your platform's audio library, but that you should be able to do, or I keep a copy of yssimplesound library under samples directory, which is a light-weight and portable audio-playing library.

This library is a spin off from my Tsugaru project (http://ysflight.in.coocan.jp/FM/towns/Tsugaru/e.html  Japanese version is http://ysflight.in.coocan.jp/FM/towns/Tsugaru/j.html).





## General Programming Pattern

If you are comfortable with programming audio stream, the recommended programming pattern is:

```
    (Add MML music to the library)

    Generate wave for short time like 100ms

    while(until the user wants to close)
    {
        if the audio-playing library can take the next piece
        {
            Send wave to the audio library
            Prepare next wave for 100ms
        }

        Do something fancy
    }
```

But, in the course of development, I figured DirectSound was giving me shameful 70ms latency and my Ubuntu was giving me appalling 80ms latency.  macOS's AVAudioEngine played with 20ms latency with comfort.  In fact DirectSound is really a shame because if I poll the playback-state play 10ms segments after another (which gives you maximum 20ms latency), it plays with no noticeable gap.  Audio-library developers presumably are not serious about supporting streaming mode except Apple.

If that is bad enough to discourage you from using the streaming mode, here's another pattern:

```
    (Add MML music to the library)

    std::vector <unsigned char> waveBuffer;
    while(until all the MML sequence is covered)
    {
        Generate wave for something like 1 second
        Add to the waveBuffer
    }

    Start playing the waveBuffer

    while(until the user wants to close)
    {
        Do something cool
    }
```


## Moon Light Sonata Example

Let's take a look at an example that plays Beethoven's Moon Light Sonata.  The source file is    samples/moonlight/main.cpp

The program includes three headers, mmlplayer.h, fssimplewindow.h, and yssimplesound.h.  mmlplayer.h is my MML wave generator.  fssimplewindow.h is my simple single-window library that I use for YS FLIGHT SIMULATOR, Tsugaru, variety of my research projects, and for my teaching.  yssimplesound.h is my minimalist audio-playing library.  It is a wrapper for DirectSound, AVAudioEngine, and ALSA in Windows, macOS, and Linux respectively.

The first part of the program is for registering MML to my MML wave generator.  You'll see a bunch of mmlplayer.AddSegment function calls.

AddSegment function adds a segment of a music as it says.  A segment is a part of music.  You can make it one measure per segment.  Or, a few measures per segment.  The playback will be synchronized at the beginning of each segment.  Therefore, if one channel of a segment is longer than another channel, the shorter channel will wait until the longer channel finishes the segment before moving on to the next segment.

My MML wave generator is based on my YM2612 emulator, which has six channels.  So, you specify six strings of MML for each segment.  In this example, I am using only three channels.

```
#include "mmlplayer.h"
#include "fssimplewindow.h"
#include "yssimplesound.h"

int main(void)
{
	MMLSegmentPlayer mmlplayer;

	mmlplayer.AddSegment(
		"@2T90L12V12",
		"@2T90L2S0M6000",
		"@2T90L4V12",
		"","","");

	mmlplayer.AddSegment(
		"O3G+O4C+EO3G+O4C+EO3G+O4C+EO3G+O4C+E",
		"O3C+1",
		"O2C+1",
		"","","");
```

After that, the sample opens a window, start sound player and then generate short waves and send to the stream.  The window closes when you press the ESC key.

The sampling rate of the wave is fixed at YM2612::WAVE_SAMPLING_RATE.

```
	FsOpenWindow(0,0,800,600,0);

	YsSoundPlayer player;
	player.Start();

	YsSoundPlayer::Stream stream;
	player.StartStreaming(stream);

	YsSoundPlayer::SoundData nextWave;
	auto rawWave=mmlplayer.GenerateWave(1000);  // Create for next 100ms
	nextWave.CreateFromSigned16bitStereo(YM2612::WAVE_SAMPLING_RATE,rawWave);

	for(;;)
	{
		FsPollDevice();

		player.KeepPlaying();  // <- This line is only needed for Linux ALSA.

		auto key=FsInkey();
		if(FSKEY_ESC==key)
		{
			break;
		}

		if(YSTRUE==player.StreamPlayerReadyToAcceptNextSegment(stream,nextWave))
		{
			player.AddNextStreamingSegment(stream,nextWave);
			auto rawWave=mmlplayer.GenerateWave(1000);  // Create for next 100ms
			nextWave.CreateFromSigned16bitStereo(YM2612::WAVE_SAMPLING_RATE,rawWave);
		}
	}

	player.End();

	return 0;
}
```


## Error Checking
MML errors may be detected during GenerateWave.  If there were errors, GetLastErrorCode() returns non-zero, and you can get a formatted text by GetLastError().Format().  For example, the following code prints error messages if any.  See also samples/error_handling

```
	YsSoundPlayer::SoundData nextWave;
	auto rawWave=mmlplayer.GenerateWave(1000);
	if(0!=mmlplayer.GetLastErrorCode())
	{
		for(auto msg : mmlplayer.GetLastError().Format())
		{
			std::cout << msg << std::endl;
		}
	}
```


## MML Commands

### CDEFGAB
A note.
An alphabet can be followed by # or + to make it half tone up, or - for half tone down.
And a number following a tone means the length.  For example, C4 is a quarter note, A#8 is an 8th note.  If a number is followed by a dot (.), the tone plays 1.5 times longer.  If no number is specified, the default length is used.

### R
Rest.  The length can be specified by the number after R.  If no number is specified, the default length is used.

### &
Connect two notes into one.  For example, "F4&F8" is same as "F4."

### O
Octave.  Like "O4A" will make 440Hz tone.  The octave will be valid until the next O command appears.

### V
Volume.  V0 is minimum. V15 is maximum.

### L
Default length.  It is valid until the next L command appears.  By writing "L8CDEF", the four notes are 8th notes.

### T
Tempo.  The number following T is the number of the quarter notes played in one minute.

### @
Instrument type.  See Instruments section for more details.

### >
Go one octave up.

### <
Go one octabe down.




## Instruments

MMLPlayer and MMLSegmentPlayer classes have the following default instruments.

```
1  E.PIANO
2  PIANO
3  TRUMPET
4  TRUMPET
5  HARPSICHORD
6  ORGAN
7  OBOE
8  CLARINET
9  WOODWIND
10 GUITAR
11 KOTO
12 HARP
13 E.BASE
14 DRUM
15 DRUM
16 BELL
17 BELL
18 BELL
19 ELECTRIC
20 ELECTRIC
21 ELECTRIC
22 METALLIC
23 METALLIC
24 METALLIC
25 METALLIC
26 PSG
27 FNYON
28 NOISE
```

Or, you can make your own.  You can import an instrument format called .FMB format, which was used by FM TOWNS Sound BIOS.  The structure of the binary is:

```
+0   8 bytes   Name in C string
+8   48 bytes  Instrument 1
+56  48 bytes  Instrument 2
        :
    (Continues all the way to Instrument 128)
```

The length is always 6152 bytes, which can include up to 128 instruments.  Actually, it is not "up to".  You should fill zeros for the unused instruments.

The instrument format is:

```
+0   8 bytes  Name of the instrument
+8   4 bytes  DT and MULTI for slots 0 to 3.
+12  4 bytes  TL for slots 0 to 3.
+16  4 bytes  KS and AR for slots 0 to 3.
+20  4 bytes  AM and DR for slots 0 to 3.
+24  4 bytes  SR for slots 0 to 3.
+28  4 bytes  SL and RR for slots 0 to 3.
+32  1 byte   FB and CNCT
+33  1 byte   L, R, AMS, and PMS
+34  14 bytes zero padding.
```

Some bytes are combination of two parameters like DT and MULTI.  Those bytes are the values written to YM2612 registers.

You can use MMLPLayer::LoadFMB (MMLSegmentPlayer::LoadFMB) function to give 6152 bytes of the FMB data to the player.